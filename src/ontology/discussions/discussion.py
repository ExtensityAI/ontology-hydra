from collections.abc import Callable

from pydantic import BaseModel, Field

from ontology.personas.personas import Persona
from ontology.utils import rng


class Participant(BaseModel):
    persona: Persona
    speaking_budget: int  # problem: this way we lose the initial speaking budget, but maybe we don't need it?

    def deduct(self, cost: int):
        # todo raise error or sth if exhausted?
        self.speaking_budget = max(0, self.speaking_budget - cost)


class Thought(BaseModel):
    response: str = Field(..., description="What you want to say")
    # allow to name the next speaker


class ActResult(BaseModel):
    thought: Thought
    """should be generated by the model"""

    cost: int
    """speaking budget cost of the speaker's response"""


class Turn(BaseModel):
    speaker: Participant
    thought: Thought
    cost: int

    @property
    def text(self):
        return self.thought.response


ActFunction = Callable[["Discussion", Participant], ActResult]
"""let a participant act in the discussion"""

# ideally, we allocate some budget for the discussion, which is spent on each turn, it ends when the budget is exhausted. also, it should always yield a result. consider giving different speaking time based on priority of the expert's group?


class DiscussionState(BaseModel):
    topic: str
    participants: list[Participant]
    protocol: list[Turn]


class Discussion:
    def __init__(self, topic: str, participants: list[Participant], act: ActFunction):
        self._act = act
        self.state = DiscussionState(
            topic=topic,
            participants=participants,
            protocol=[],
        )

    @property
    def remaining_budget(self):
        return sum(p.speaking_budget for p in self.state.participants)

    @property
    def is_finished(self):
        return self.remaining_budget == 0

    def _choose_next_speaker(self):
        # if someone was asked a question, they should be the next speaker TODO

        last_speaker = self.state.protocol[-1].speaker if self.state.protocol else None

        other_participants = [p for p in self.state.participants if p != last_speaker]

        # weighted random choice based on the speaking budget
        remaining_budget = self.remaining_budget - (
            last_speaker.speaking_budget if last_speaker else 0
        )

        idx = rng.choice(
            len(other_participants),
            p=[p.speaking_budget / remaining_budget for p in other_participants],
        )

        return other_participants[idx]

    def proceed(self):
        speaker = self._choose_next_speaker()
        print("next speaker is", speaker.persona.name)
        result = self._act(self, speaker)

        print("response:", result.thought.response, "\ncost:", result.cost)

        speaker.deduct(result.cost)

        self.state.protocol.append(
            Turn(speaker=speaker, thought=result.thought, cost=result.cost)
        )

        return self.is_finished
